//import required modules
import axios from 'axios';
import admin from 'firebase-admin';
import { Buffer } from 'buffer';

const serviceAccount = {
  "type": "service_account",
  "project_id": "gostarterai",
  "private_key": process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n'),
  "client_email": "firebase-adminsdk-fbsvc@gostarterai.iam.gserviceaccount.com",
  "private_key_id": process.env.FIREBASE_PRIVATE_KEY_ID,
  "client_id": process.env.FIREBASE_CLIENT_ID,
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40gostarterai.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
};

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: "https://gostarterai-default-rtdb.firebaseio.com",
  });
}

const db = admin.database();

/**
 * Create a new repository and set default branch to main
 */
const createNewRepo = async (accessToken, repoName) => {
  const headers = {
    'Authorization': `token ${accessToken}`,
    'Accept': 'application/vnd.github.v3+json',
  };

  try {
    // 1. Create repo (default is master if auto_init: true)
    const response = await axios.post(
      `https://api.github.com/user/repos`,
      {
        name: repoName,
        private: false,
        description: 'This business website was automatically generated by GoStarterAI - your all-in-one business launchpad!',
        auto_init: true,
      },
      { headers }
    );

    const { owner, name, default_branch } = response.data;
    console.log(`Repository '${repoName}' created with default branch ${default_branch}`);

    // 2. If default branch is master, create main branch from it
    if (default_branch !== 'main') {
      // Get master branch commit SHA
      const masterBranch = await axios.get(
        `https://api.github.com/repos/${owner.login}/${name}/git/ref/heads/${default_branch}`,
        { headers }
      );
      const sha = masterBranch.data.object.sha;

      // Create main branch from master
      await axios.post(
        `https://api.github.com/repos/${owner.login}/${name}/git/refs`,
        {
          ref: 'refs/heads/main',
          sha,
        },
        { headers }
      );
      console.log(`Main branch created from ${default_branch} (${sha})`);

      // Switch default branch to main
      await axios.patch(
        `https://api.github.com/repos/${owner.login}/${name}`,
        { default_branch: 'main' },
        { headers }
      );
      console.log(`Default branch switched to main`);
    }

    return {
      success: true,
      owner: owner.login,
      name,
      html_url: response.data.html_url,
    };

  } catch (error) {
    const message = error.response?.data?.message || error.message;
    console.error('Error creating new repository:', message);
    return { success: false, error: message };
  }
};
/**
 * Helper: Create or update a file in repo on main
 */
const pushFile = async (accessToken, repoOwner, repoName, filePath, fileContent, commitMessage) => {
  const headers = {
    'Authorization': `token ${accessToken}`,
    'Accept': 'application/vnd.github.v3+json',
  };

  const encodedContent = Buffer.from(fileContent).toString('base64');
  let sha;

  try {
    const res = await axios.get(
      `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${filePath}?ref=main`,
      { headers }
    );
    sha = res.data.sha;
  } catch (err) {
    if (err.response?.status !== 404) throw err; // ignore only 404
  }

  await axios.put(
    `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${filePath}`,
    {
      message: commitMessage,
      content: encodedContent,
      branch: 'main', // force to main
      sha,
    },
    { headers }
  );

  console.log(`${filePath} pushed successfully.`);
};

/**
 * Push project files (index.html + README only)
 */
const pushCodeToRepo = async (accessToken, repoOwner, repoName, websiteCode) => {
  try {
    // index.html
    await pushFile(
      accessToken,
      repoOwner,
      repoName,
      'index.html',
      websiteCode,
      'Add or update index.html'
    );

    // README.md
    await pushFile(
      accessToken,
      repoOwner,
      repoName,
      'README.md',
      `# ${repoName}\n\nGenerated by GoStarterAI üöÄ`,
      'Add README.md'
    );

    console.log('‚úÖ Repo initialized with index.html + README.md');
    return { success: true };

  } catch (error) {
    const message = error.response?.data?.message || error.message;
    console.error('‚ùå Error pushing files:', message);
    return { success: false, error: message };
  }
};
// Main handler for the Cloud Function
export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  const { code, state } = req.query;
  if (!code || !state) {
    return res.status(400).json({ error: 'Temporary code or state is missing.' });
  }

  const stateRef = db.ref(`oauth_states/${state}`);
  const stateSnapshot = await stateRef.once('value');

  if (!stateSnapshot.exists()) {
    return res.status(400).json({ error: 'Invalid or expired state parameter.' });
  }

  const { userId, businessId, idToken } = stateSnapshot.val();
  await stateRef.remove();

  let decodedToken;
  try {
    decodedToken = await admin.auth().verifyIdToken(idToken);
  } catch (error) {
    console.error('Error verifying Firebase ID token:', error);
    return res.status(401).json({ error: 'Unauthorized: Invalid Firebase ID token.' });
  }

  if (decodedToken.uid !== userId) {
    return res.status(403).json({ error: 'Forbidden: Session user mismatch.' });
  }

  const businessRef = db.ref(`users/${userId}/businesses/${businessId}`);
  const businessSnapshot = await businessRef.once('value');
  if (!businessSnapshot.exists()) {
    return res.status(404).json({ error: 'Business not found.' });
  }

  const businessData = businessSnapshot.val();
  const repoName = businessData.businessName.toLowerCase().replace(/\s+/g, '-');

  // Exchange GitHub code for access token
  const CLIENT_ID = process.env.GITHUB_CLIENT_ID;
  const CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET;
  let accessToken;
  try {
    const response = await fetch('https://github.com/login/oauth/access_token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET,
        code,
      }),
    });

    const data = await response.json();
    accessToken = data.access_token;
    if (!accessToken) {
      return res.status(500).json({ error: 'Access token not found.' });
    }
  } catch (error) {
    console.error('Error exchanging GitHub code:', error);
    return res.status(500).json({ error: 'Token exchange failed.' });
  }

  // Create repo
  const repoResult = await createNewRepo(accessToken, repoName);
  if (!repoResult.success) {
    return res.status(500).json({ error: repoResult.error });
  }

  const { owner, name } = repoResult;

  // Retry pushes (branch propagation)
  let pushResult = { success: false };
  for (let attempt = 1; attempt <= 5; attempt++) {
    pushResult = await pushCodeToRepo(accessToken, owner, name, businessData.websiteCode);
    if (pushResult.success) break;
    const delay = Math.pow(2, attempt) * 1000;
    console.warn(`Push attempt ${attempt} failed: ${pushResult.error}. Retrying in ${delay / 1000}s`);
    await new Promise(r => setTimeout(r, delay));
  }

  if (!pushResult.success) {
    return res.status(500).json({ error: `Repo created but push failed: ${pushResult.error}` });
  }

  await businessRef.update({
    isHosted: true,
    hostedRepoLink: repoResult.html_url,
  });

  return res.redirect(`https://go-starter-ai.vercel.app/dashboard.html?id=${businessId}`);
}